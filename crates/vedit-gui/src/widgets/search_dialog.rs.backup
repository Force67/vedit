use iced::widget::{button, checkbox, container, row, text, text_input, column, horizontal_space};
use iced::{Element, Color, Length, Padding, Alignment};
use iced_font_awesome::fa_icon_solid;
use crate::message::Message;
use crate::style::{panel_container, custom_button};
use iced::widget::text_input::Id;

#[derive(Debug, Clone)]
pub struct SearchDialog {
    pub is_visible: bool,
    pub search_query: String,
    pub case_sensitive: bool,
    pub whole_word: bool,
    pub use_regex: bool,
    pub current_match: Option<usize>,
    pub total_matches: usize,
    pub replace_mode: bool,
    pub replace_text: String,
    pub search_state: SearchState,
    pub pending_search: bool,
    pub search_input_id: Id,
}

#[derive(Debug, Clone, PartialEq)]
pub enum SearchState {
    Idle,
    Searching,
    Complete,
    NoMatches,
}

impl Default for SearchDialog {
    fn default() -> Self {
        Self {
            is_visible: false,
            search_query: String::new(),
            case_sensitive: false,
            whole_word: false,
            use_regex: false,
            current_match: None,
            total_matches: 0,
            replace_mode: false,
            replace_text: String::new(),
            search_state: SearchState::Idle,
            pending_search: false,
            search_input_id: Id::unique(),
        }
    }
}

impl SearchDialog {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn show(&mut self) {
        self.is_visible = true;
    }

    pub fn get_search_input_id(&self) -> Id {
        self.search_input_id.clone()
    }

    pub fn hide(&mut self) {
        self.is_visible = false;
        self.search_query.clear();
        self.replace_text.clear();
        self.current_match = None;
        self.total_matches = 0;
        self.search_state = SearchState::Idle;
        self.pending_search = false;
    }

    pub fn toggle(&mut self) {
        if self.is_visible {
            self.hide();
        } else {
            self.show();
        }
    }

    pub fn set_search_query(&mut self, query: String) {
        self.search_query = query.clone();
        if !query.is_empty() && query != self.search_query {
            self.pending_search = true;
            self.search_state = SearchState::Idle;
        }
    }

    pub fn set_search_state(&mut self, state: SearchState) {
        self.search_state = state;
        self.pending_search = false;
    }

    pub fn start_search(&mut self) {
        if !self.search_query.is_empty() {
            self.search_state = SearchState::Searching;
            self.pending_search = false;
        }
    }

    pub fn complete_search(&mut self, total_matches: usize) {
        self.total_matches = total_matches;
        if total_matches > 0 {
            self.current_match = Some(0);
            self.search_state = SearchState::Complete;
        } else {
            self.current_match = None;
            self.search_state = if self.search_query.is_empty() {
                SearchState::Idle
            } else {
                SearchState::NoMatches
            };
        }
    }

    pub fn set_replace_text(&mut self, text: String) {
        self.replace_text = text;
    }

    pub fn set_case_sensitive(&mut self, case_sensitive: bool) {
        self.case_sensitive = case_sensitive;
    }

    pub fn set_whole_word(&mut self, whole_word: bool) {
        self.whole_word = whole_word;
    }

    pub fn set_use_regex(&mut self, use_regex: bool) {
        self.use_regex = use_regex;
    }

    pub fn set_matches(&mut self, current: Option<usize>, total: usize) {
        self.current_match = current;
        self.total_matches = total;
    }

    pub fn enable_replace_mode(&mut self) {
        self.replace_mode = true;
    }

    pub fn disable_replace_mode(&mut self) {
        self.replace_mode = false;
    }

    pub fn view(&self, scale: f32) -> Element<Message> {
        if !self.is_visible {
            return container(row![])
                .height(Length::Fixed(0.0))
                .width(Length::Fixed(0.0))
                .into();
        }

        let spacing = 8.0 * scale;
        let padding = Padding::from([spacing, spacing * 1.5]);

        // Search input row
        let search_input = text_input("Find", &self.search_query)
            .id(self.search_input_id.clone())
            .on_input(Message::SearchQueryChanged)
            .on_paste(Message::SearchQueryChanged)
            .on_submit(Message::SearchExecute)
            .size(14.0 * scale)
            .padding(4.0 * scale);

        let search_row = row![
            fa_icon_solid("search")
                .size(14.0 * scale)
                .color(Color::from_rgb8(180, 180, 180)),
            search_input,
            button(fa_icon_solid("chevron-up")
                .size(12.0 * scale)
                .color(iced::Color::WHITE))
                .style(custom_button())
                .on_press(Message::SearchPrevious)
                .padding(4.0 * scale)
                .width(Length::Fixed(30.0 * scale)),
            button(fa_icon_solid("chevron-down")
                .size(12.0 * scale)
                .color(iced::Color::WHITE))
                .style(custom_button())
                .on_press(Message::SearchNext)
                .padding(4.0 * scale)
                .width(Length::Fixed(30.0 * scale)),
        ]
        .spacing(spacing)
        .align_items(Alignment::Center);

        // Replace input row (visible when replace mode is enabled)
        let replace_row = if self.replace_mode {
            let replace_input = text_input("Replace", &self.replace_text)
                .on_input(Message::ReplaceTextChanged)
                .on_paste(Message::ReplaceTextChanged)
                .size(14.0 * scale)
                .padding(4.0 * scale);

            Some(row![
                fa_icon_solid("exchange-alt")
                    .size(14.0 * scale)
                    .color(Color::from_rgb8(180, 180, 180)),
                replace_input,
                button(fa_icon_solid("sync")
                    .size(12.0 * scale)
                    .color(iced::Color::WHITE))
                    .style(custom_button())
                    .on_press(Message::ReplaceOne)
                    .padding(4.0 * scale),
                button(fa_icon_solid("sync-alt")
                    .size(12.0 * scale)
                    .color(iced::Color::WHITE))
                    .style(custom_button())
                    .on_press(Message::ReplaceAll)
                    .padding(4.0 * scale),
            ]
            .spacing(spacing)
            .align_items(Alignment::Center))
        } else {
            None
        };

        // Options row
        let case_checkbox = checkbox("", self.case_sensitive)
            .on_toggle(Message::SearchCaseSensitive)
            .spacing(4.0 * scale)
            .size(14.0 * scale);

        let whole_word_checkbox = checkbox("", self.whole_word)
            .on_toggle(Message::SearchWholeWord)
            .spacing(4.0 * scale)
            .size(14.0 * scale);

        let regex_checkbox = checkbox("", self.use_regex)
            .on_toggle(Message::SearchUseRegex)
            .spacing(4.0 * scale)
            .size(14.0 * scale);

        let options_row = row![
            case_checkbox,
            row![
                fa_icon_solid("font")
                    .size(11.0 * scale)
                    .color(Color::from_rgb8(140, 140, 140)),
                text("Match Case").size(12.0 * scale)
            ].spacing(4.0),
            whole_word_checkbox,
            row![
                fa_icon_solid("text-height")
                    .size(11.0 * scale)
                    .color(Color::from_rgb8(140, 140, 140)),
                text("Whole Word").size(12.0 * scale)
            ].spacing(4.0),
            regex_checkbox,
            row![
                fa_icon_solid("asterisk")
                    .size(11.0 * scale)
                    .color(Color::from_rgb8(140, 140, 140)),
                text("Regex").size(12.0 * scale)
            ].spacing(4.0),
        ]
        .spacing(spacing * 1.5)
        .align_items(Alignment::Center);

        // Results text
        let results_text = match self.search_state {
            SearchState::Searching => "Searching...".to_string(),
            SearchState::Complete => {
                if let Some(current) = self.current_match {
                    format!("{} of {} matches", current + 1, self.total_matches)
                } else {
                    format!("{} matches", self.total_matches)
                }
            }
            SearchState::NoMatches => "No matches".to_string(),
            SearchState::Idle => {
                if self.pending_search {
                    "Press Enter to search".to_string()
                } else if !self.search_query.is_empty() {
                    "Press Enter to search".to_string()
                } else {
                    "".to_string()
                }
            }
        };

        let results_color = match self.search_state {
            SearchState::Searching => Color::from_rgb8(100, 150, 200), // Light blue
            SearchState::Complete => Color::from_rgb8(140, 140, 140),  // Gray
            SearchState::NoMatches => Color::from_rgb8(200, 100, 100), // Light red
            SearchState::Idle => Color::from_rgb8(160, 160, 160),     // Lighter gray
        };

        let results_label = text(results_text)
            .size(12.0 * scale)
            .style(results_color);

        // Close button
        let close_button = button(fa_icon_solid("times")
                .size(14.0 * scale)
                .color(iced::Color::WHITE))
            .style(custom_button())
            .on_press(Message::SearchClose)
            .padding(4.0 * scale)
            .width(Length::Fixed(24.0 * scale))
            .height(Length::Fixed(24.0 * scale));

        // Header row with title and close button
        let header_row = row![
            fa_icon_solid("search")
                .size(16.0 * scale)
                .color(Color::from_rgb8(180, 180, 180)),
            text("Search").size(16.0 * scale),
            horizontal_space(),
            close_button,
        ]
        .align_items(Alignment::Center);

        // Main content column
        let mut content = column![
            header_row,
            search_row,
            options_row,
            row![results_label, horizontal_space()],
        ]
        .spacing(spacing);

        // Add replace row if in replace mode
        if let Some(replace_row) = replace_row {
            content = content.push(replace_row);
        }

        // Action buttons row
        let mut action_buttons = row![
            button(row![
                fa_icon_solid("exchange-alt")
                    .size(12.0 * scale)
                    .color(iced::Color::WHITE),
                text("Toggle Replace").size(12.0 * scale)
            ].spacing(4.0))
                .style(custom_button())
                .on_press(Message::SearchToggleReplace)
                .padding(6.0 * scale),
        ]
        .spacing(spacing)
        .align_items(Alignment::Center);

        // Add Next Match button if there are multiple matches
        if self.search_state == SearchState::Complete && self.total_matches > 1 {
            action_buttons = action_buttons.push(
                button(row![
                    fa_icon_solid("arrow-down")
                        .size(12.0 * scale)
                        .color(iced::Color::WHITE),
                    text("Next Match").size(12.0 * scale)
                ].spacing(4.0))
                    .style(custom_button())
                    .on_press(Message::SearchNext)
                    .padding(6.0 * scale)
            );
        }

        action_buttons = action_buttons.push(
            button(row![
                fa_icon_solid("times")
                    .size(12.0 * scale)
                    .color(iced::Color::WHITE),
                text("Close").size(12.0 * scale)
            ].spacing(4.0))
                .style(custom_button())
                .on_press(Message::SearchClose)
                .padding(6.0 * scale)
        );

        content = content.push(action_buttons);

        // Wrap in container with styling
        container(content)
            .padding(padding)
            .width(Length::Fill)
            .style(panel_container())
            .into()
    }
}